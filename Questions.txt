Q1: Add a private static array of vectors of Move objects, containing the opening sequences (with move order in reverse), to the AI class, as well as a non-static vector of vectors of move objects, containing the currently valid sequences (with the last move at the front). Additionally, add a lastMove field and getLastMove function to Game, which will store a move when executeMove() is called, and return the last move executed, respectively. Then, when the AI is taking its turn, it will compare Game.getLastMove() to the back of the vector of move sequences. If they don’t match, remove the move sequence, and if they do, remove the move from the sequence. After processing every move sequence, chose a random move sequence, and repeat the process using the next move in the chosen sequence instead of getLastMove(), then return the move.
Q2: Add a vector of pairs of Moves and piece pointers to Game, with the piece pointer’s representing any piece captured. Then, when undoing a move, (with a call to Game.undo()) set the board at Move.origin to the piece at Move.destination, and set Move.destination to the piece captured (which, if there was none will be null)
Q3: the size of board would need to be enlarged, and checks performed to ensure that pieces never move to the 2x2 squares in each corner. Additionally, everywhere a bool is used to represent colour, we would need to change to an int (from 1-4). We would probably have a constant, static 2x4 array used to convert the player number to an x,y direction. Lastly, there would be a couple of minor tweaks, such as increasing Controller.players from size 2 to size 4, and changing loop conditions
